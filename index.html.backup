<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Colony Game</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
        }

        /* Mobile-first responsive layout */
        .mobile-ui {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            pointer-events: none;
        }

        /* Collapsible resource panel */
        #resource-panel {
            position: fixed;
            top: env(safe-area-inset-top, 10px);
            left: 10px;
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 16px;
            color: white;
            z-index: 1001;
            pointer-events: auto;
            transform: translateY(0);
            transition: transform 0.3s ease;
            min-width: 140px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        #resource-panel.collapsed {
            transform: translateY(calc(-100% + 40px));
        }

        .resource-toggle {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 20px;
            background: rgba(20, 20, 30, 0.95);
            border-radius: 0 0 16px 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }

        .resource-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            font-size: 14px;
            font-weight: 500;
        }

        .resource-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        /* Floating Action Buttons */
        .fab-container {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 20px);
            right: 20px;
            z-index: 1001;
            pointer-events: auto;
        }

        .fab {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
            position: relative;
        }

        .fab:active {
            transform: scale(0.95);
        }

        .fab.main-fab {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            transform: rotate(0deg);
            transition: transform 0.3s ease;
        }

        .fab.main-fab.open {
            transform: rotate(45deg);
        }

        .sub-fabs {
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .sub-fabs.open {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .sub-fab {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            font-size: 20px;
            position: relative;
        }

        .sub-fab.house { background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%); }
        .sub-fab.farm { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
        .sub-fab.mine { background: linear-gradient(135deg, #d299c2 0%, #fef9d7 100%); }
        .sub-fab.worker { background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%); }

        /* Context menu */
        .context-menu {
            position: fixed;
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px;
            color: white;
            z-index: 1002;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            transform: scale(0);
            transition: transform 0.2s ease;
            pointer-events: auto;
        }

        .context-menu.show {
            transform: scale(1);
        }

        .context-menu-item {
            padding: 12px 16px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.2s;
            font-size: 14px;
            display: flex;
            align-items: center;
        }

        .context-menu-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .context-menu-item .icon {
            width: 20px;
            margin-right: 8px;
        }

        /* Zoom controls */
        .zoom-controls {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 20px);
            left: 20px;
            z-index: 1001;
            pointer-events: auto;
        }

        .zoom-btn {
            width: 48px;
            height: 48px;
            background: rgba(20, 20, 30, 0.9);
            border: none;
            border-radius: 24px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: block;
            margin-bottom: 8px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:active {
            transform: scale(0.9);
            background: rgba(30, 30, 40, 0.9);
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1003;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .tooltip.show {
            opacity: 1;
        }

        /* Cost indicator */
        .cost-indicator {
            position: absolute;
            bottom: -6px;
            right: -6px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 600;
        }

        /* Responsive design */
        @media (max-width: 480px) {
            #resource-panel {
                left: 5px;
                top: env(safe-area-inset-top, 5px);
                min-width: 120px;
                padding: 12px;
            }

            .fab {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }

            .zoom-btn {
                width: 42px;
                height: 42px;
                font-size: 18px;
            }
        }

        @media (orientation: landscape) {
            .fab-container {
                right: 10px;
                bottom: 10px;
            }
            
            .zoom-controls {
                left: 10px;
                bottom: 10px;
            }
        }

        /* Loading indicator */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 2000;
        }

        /* Pulse animation for active elements */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 1s infinite;
        }

        /* Resource sections */
        .resource-section {
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 8px;
            margin-bottom: 8px;
        }

        .resource-section h4 {
            margin: 4px 0;
            color: #ccc;
            font-size: 12px;
        }

        .spoilage {
            color: #ff6b6b;
            font-size: 0.8em;
        }

        /* Market UI */
        #market-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 16px;
            color: white;
            z-index: 1001;
            display: none;
            min-width: 300px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <h3>Colony Stats</h3>
        <div class="resource-section">
            <div>Population: <span id="population">5</span></div>
            <div>Storage: <span id="storage-used">0</span>/<span id="storage-capacity">100</span></div>
        </div>
        
        <div class="resource-section">
            <h4>Basic Resources</h4>
            <div>Food: <span id="food">50</span> <span id="food-spoil" class="spoilage"></span></div>
            <div>Wood: <span id="wood">30</span></div>
            <div>Stone: <span id="stone">20</span></div>
            <div>Iron: <span id="iron">5</span></div>
        </div>
        
        <div class="resource-section">
            <h4>Manufactured</h4>
            <div>Tools: <span id="tools">0</span></div>
            <div>Cloth: <span id="cloth">0</span></div>
            <div>Meals: <span id="meals">0</span> <span id="meals-spoil" class="spoilage"></span></div>
            <div>Medicine: <span id="medicine">0</span> <span id="medicine-spoil" class="spoilage"></span></div>
        </div>
        
        <div class="resource-section">
            <h4>Knowledge & Skills</h4>
            <div>Knowledge: <span id="knowledge">0</span></div>
            <div>Avg Skill: <span id="avg-skill">1.0</span></div>
        </div>
    </div>
    
    <div id="controls">
        <div id="building-tabs">
            <button onclick="showBuildingCategory('housing')" class="tab-btn active">Housing</button>
            <button onclick="showBuildingCategory('production')" class="tab-btn">Production</button>
            <button onclick="showBuildingCategory('infrastructure')" class="tab-btn">Infrastructure</button>
            <button onclick="showBuildingCategory('defense')" class="tab-btn">Defense</button>
            <button onclick="showBuildingCategory('culture')" class="tab-btn">Culture</button>
        </div>
        <div id="building-options"></div>
        <div style="margin-top: 10px;">
            <button onclick="spawnWorker()">Hire Worker (10 food)</button>
            <button onclick="togglePause()">Pause/Resume</button>
        </div>
        <div id="selected-info" style="margin-top: 10px; font-size: 12px; max-width: 200px;"></div>
    </div>

    <div id="market-panel">
        <h3>Market</h3>
        <div id="market-trades"></div>
        <div style="margin-top: 10px;">
            <button onclick="toggleMarket()">Close Market</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Name pools for generating unique colonists
        const namePool = {
            male: ['Alex', 'Ben', 'Charlie', 'David', 'Ethan', 'Frank', 'George', 'Henry', 'Ivan', 'Jack', 'Kyle', 'Luke', 'Mark', 'Nathan', 'Oscar', 'Paul', 'Quinn', 'Ryan', 'Sam', 'Tom'],
            female: ['Alice', 'Beth', 'Clara', 'Diana', 'Emma', 'Fiona', 'Grace', 'Hannah', 'Iris', 'Jane', 'Kate', 'Luna', 'Maya', 'Nina', 'Olivia', 'Penny', 'Quinn', 'Rose', 'Sara', 'Tina']
        };

        const traits = ['Hardworking', 'Lazy', 'Cheerful', 'Grumpy', 'Social', 'Introverted', 'Creative', 'Logical', 'Patient', 'Impatient', 'Brave', 'Cautious', 'Optimistic', 'Pessimistic'];
        const personalities = ['Leader', 'Follower', 'Independent', 'Team Player', 'Perfectionist', 'Adventurer', 'Homebody', 'Helper'];

        // Job types with skills and responsibilities
        const jobTypes = {
            farmer: { color: 0x9ACD32, skills: ['farming', 'strength'], produces: 'food', baseEfficiency: 1.2 },
            builder: { color: 0x8B4513, skills: ['construction', 'strength'], produces: 'buildings', baseEfficiency: 1.0 },
            miner: { color: 0x696969, skills: ['mining', 'endurance'], produces: 'stone', baseEfficiency: 1.1 },
            gatherer: { color: 0x228B22, skills: ['gathering', 'speed'], produces: 'wood', baseEfficiency: 1.0 },
            scholar: { color: 0x4B0082, skills: ['intelligence', 'creativity'], produces: 'research', baseEfficiency: 0.8 }
        };

        // Game state with advanced resource management
        const gameState = {
            population: 5,
            resources: {
                food: { amount: 50, decay: 0.02, maxDecay: 0.5, storage: 0 },
                wood: { amount: 30, decay: 0, storage: 0 },
                stone: { amount: 20, decay: 0, storage: 0 },
                iron: { amount: 5, decay: 0, storage: 0 },
                tools: { amount: 0, decay: 0.001, storage: 0 },
                cloth: { amount: 0, decay: 0.003, storage: 0 },
                meals: { amount: 0, decay: 0.05, maxDecay: 0.8, storage: 0 },
                medicine: { amount: 0, decay: 0.01, maxDecay: 0.3, storage: 0 },
                knowledge: { amount: 0, decay: 0, storage: 0 }
            },
            storage: {
                used: 0,
                capacity: 100,
                buildings: []
            },
            workers: {
                list: [],
                skills: {
                    farming: 1.0,
                    mining: 1.0,
                    crafting: 1.0,
                    research: 1.0,
                    logistics: 1.0
                },
                experience: {}
            },
            buildings: [],
            colonists: [],
            time: 0,
            selectedColonist: null,
            gridSize: 50,
            cellSize: 1,
            market: {
                prices: {
                    food: 1.0, wood: 1.2, stone: 1.5, iron: 2.0,
                    tools: 5.0, cloth: 3.0, meals: 2.5, medicine: 8.0, knowledge: 10.0
                },
                demand: {
                    food: 1.0, wood: 1.0, stone: 1.0, iron: 1.0,
                    tools: 1.0, cloth: 1.0, meals: 1.0, medicine: 1.0, knowledge: 1.0
                },
                trades: []
            },
            recipes: {
                tools: { inputs: { wood: 5, iron: 2 }, output: { tools: 1 }, time: 150, skill: 'crafting' },
                meals: { inputs: { food: 3 }, output: { meals: 2 }, time: 50, skill: 'crafting' },
                medicine: { inputs: { cloth: 2, knowledge: 1 }, output: { medicine: 1 }, time: 200, skill: 'crafting' },
                cloth: { inputs: { knowledge: 1 }, output: { cloth: 2 }, time: 100, skill: 'crafting' },
                iron: { inputs: { stone: 3 }, output: { iron: 1 }, time: 100, skill: 'mining' }
            },
            logistics: {
                transports: [],
                routes: [],
                efficiency: 1.0
            },
            production: {
                queues: {},
                timers: {},
                efficiency: {}
            }
        };

        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x4a5d3a });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Camera position
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        // A* Pathfinding implementation
        class PathfindingGrid {
            constructor(size, cellSize) {
                this.size = size;
                this.cellSize = cellSize;
                this.grid = [];
                this.obstacles = new Set();
                
                // Initialize grid
                for (let x = 0; x < size; x++) {
                    this.grid[x] = [];
                    for (let z = 0; z < size; z++) {
                        this.grid[x][z] = {
                            x: x,
                            z: z,
                            walkable: true,
                            g: 0, h: 0, f: 0,
                            parent: null
                        };
                    }
                }
            }

            worldToGrid(worldX, worldZ) {
                const x = Math.floor((worldX + (this.size * this.cellSize) / 2) / this.cellSize);
                const z = Math.floor((worldZ + (this.size * this.cellSize) / 2) / this.cellSize);
                return { x: Math.max(0, Math.min(this.size - 1, x)), z: Math.max(0, Math.min(this.size - 1, z)) };
            }

            gridToWorld(gridX, gridZ) {
                const x = (gridX * this.cellSize) - (this.size * this.cellSize) / 2 + this.cellSize / 2;
                const z = (gridZ * this.cellSize) - (this.size * this.cellSize) / 2 + this.cellSize / 2;
                return { x, z };
            }

            addObstacle(worldX, worldZ, sizeX, sizeZ) {
                const start = this.worldToGrid(worldX - sizeX/2, worldZ - sizeZ/2);
                const end = this.worldToGrid(worldX + sizeX/2, worldZ + sizeZ/2);
                
                for (let x = start.x; x <= end.x; x++) {
                    for (let z = start.z; z <= end.z; z++) {
                        if (this.grid[x] && this.grid[x][z]) {
                            this.grid[x][z].walkable = false;
                            this.obstacles.add(`${x},${z}`);
                        }
                    }
                }
            }

            heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
            }

            getNeighbors(node) {
                const neighbors = [];
                const dirs = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,-1], [1,1]];
                
                for (const [dx, dz] of dirs) {
                    const x = node.x + dx;
                    const z = node.z + dz;
                    
                    if (x >= 0 && x < this.size && z >= 0 && z < this.size && this.grid[x][z].walkable) {
                        neighbors.push(this.grid[x][z]);
                    }
                }
                return neighbors;
            }

            findPath(startWorld, endWorld) {
                const start = this.worldToGrid(startWorld.x, startWorld.z);
                const end = this.worldToGrid(endWorld.x, endWorld.z);
                
                if (!this.grid[start.x] || !this.grid[start.z] || !this.grid[end.x] || !this.grid[end.z]) {
                    return [];
                }

                const startNode = this.grid[start.x][start.z];
                const endNode = this.grid[end.x][end.z];
                
                if (!startNode.walkable || !endNode.walkable) {
                    return [];
                }

                const openSet = [startNode];
                const closedSet = new Set();
                
                // Reset nodes
                for (let x = 0; x < this.size; x++) {
                    for (let z = 0; z < this.size; z++) {
                        this.grid[x][z].g = 0;
                        this.grid[x][z].h = 0;
                        this.grid[x][z].f = 0;
                        this.grid[x][z].parent = null;
                    }
                }
                
                startNode.h = this.heuristic(startNode, endNode);
                startNode.f = startNode.h;

                while (openSet.length > 0) {
                    // Find node with lowest f cost
                    let current = openSet[0];
                    let currentIndex = 0;
                    
                    for (let i = 1; i < openSet.length; i++) {
                        if (openSet[i].f < current.f) {
                            current = openSet[i];
                            currentIndex = i;
                        }
                    }

                    openSet.splice(currentIndex, 1);
                    closedSet.add(`${current.x},${current.z}`);

                    if (current === endNode) {
                        // Reconstruct path
                        const path = [];
                        let node = current;
                        while (node) {
                            const worldPos = this.gridToWorld(node.x, node.z);
                            path.unshift(new THREE.Vector3(worldPos.x, 0.5, worldPos.z));
                            node = node.parent;
                        }
                        return path;
                    }

                    const neighbors = this.getNeighbors(current);
                    for (const neighbor of neighbors) {
                        if (closedSet.has(`${neighbor.x},${neighbor.z}`)) continue;

                        const tentativeG = current.g + 1;
                        
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        } else if (tentativeG >= neighbor.g) {
                            continue;
                        }

                        neighbor.parent = current;
                        neighbor.g = tentativeG;
                        neighbor.h = this.heuristic(neighbor, endNode);
                        neighbor.f = neighbor.g + neighbor.h;
                    }
                }

                return []; // No path found
            }
        }

        // Initialize pathfinding grid
        const pathfindingGrid = new PathfindingGrid(gameState.gridSize, gameState.cellSize);

        // Building types with advanced resource management
        const buildingTypes = {
            house: { color: 0x8B4513, size: [2, 3, 2], cost: { wood: 10 }, capacity: 0, produces: null },
            farm: { color: 0x9ACD32, size: [4, 1, 4], cost: { wood: 15, stone: 5 }, capacity: 0, produces: 'food' },
            mine: { color: 0x696969, size: [3, 4, 3], cost: { wood: 20, stone: 10 }, capacity: 0, produces: 'stone' },
            ironmine: { color: 0x4A4A4A, size: [3, 4, 3], cost: { wood: 25, stone: 15, tools: 2 }, capacity: 0, produces: 'iron' },
            warehouse: { color: 0xA0522D, size: [5, 3, 5], cost: { wood: 25, stone: 10 }, capacity: 200, produces: null },
            granary: { color: 0xDAA520, size: [4, 4, 4], cost: { wood: 20, stone: 15 }, capacity: 150, produces: null, specialty: 'food' },
            workshop: { color: 0x8B008B, size: [4, 3, 4], cost: { wood: 30, stone: 20 }, capacity: 0, produces: 'tools' },
            school: { color: 0x4169E1, size: [5, 4, 5], cost: { wood: 40, stone: 25 }, capacity: 0, produces: 'knowledge' },
            clinic: { color: 0xFF1493, size: [3, 3, 3], cost: { wood: 35, stone: 15, tools: 5 }, capacity: 0, produces: 'medicine' },
            market: { color: 0xFF8C00, size: [6, 3, 6], cost: { wood: 50, stone: 30, tools: 10 }, capacity: 0, produces: null, specialty: 'trade' }
        };

        // Create initial buildings
        function createBuilding(type, x, z) {
            const buildingInfo = buildingTypes[type];
            const geometry = new THREE.BoxGeometry(...buildingInfo.size);
            const material = new THREE.MeshLambertMaterial({ color: buildingInfo.color });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, buildingInfo.size[1]/2, z);
            building.userData = { type, productivity: 0 };
            scene.add(building);
            gameState.buildings.push(building);
            return building;
        }

        // Create workers (small moving cubes)
        function createWorker() {
            const geometry = new THREE.BoxGeometry(0.5, 1, 0.5);
            const material = new THREE.MeshLambertMaterial({ color: 0xFF6B6B });
            const worker = new THREE.Mesh(geometry, material);
            worker.position.set(
                (Math.random() - 0.5) * 20,
                0.5,
                (Math.random() - 0.5) * 20
            );
            worker.userData = {
                target: null,
                speed: 0.02,
                task: 'idle',
                taskTimer: 0
            };
            scene.add(worker);
            gameState.workers.push(worker);
            return worker;
        }

        // Initial setup
        createBuilding('house', -5, -5);
        createBuilding('farm', 5, -5);
        createBuilding('mine', 0, 5);

        // Create initial workers
        for(let i = 0; i < gameState.population; i++) {
            createWorker();
        }

        // Building functions
        function buildHouse() {
            if (gameState.wood >= 10) {
                gameState.wood -= 10;
                const x = (Math.random() - 0.5) * 30;
                const z = (Math.random() - 0.5) * 30;
                createBuilding('house', x, z);
                gameState.population += 2;
                updateUI();
            }
        }

        function buildFarm() {
            if (gameState.wood >= 15 && gameState.stone >= 5) {
                gameState.wood -= 15;
                gameState.stone -= 5;
                const x = (Math.random() - 0.5) * 30;
                const z = (Math.random() - 0.5) * 30;
                createBuilding('farm', x, z);
                updateUI();
            }
        }

        function buildMine() {
            if (gameState.wood >= 20 && gameState.stone >= 10) {
                gameState.wood -= 20;
                gameState.stone -= 10;
                const x = (Math.random() - 0.5) * 30;
                const z = (Math.random() - 0.5) * 30;
                createBuilding('mine', x, z);
                updateUI();
            }
        }

        function spawnWorker() {
            if (gameState.food >= 5 && gameState.workers.length < gameState.population) {
                gameState.food -= 5;
                createWorker();
                updateUI();
            }
        }

        // Update UI
        function updateUI() {
            document.getElementById('population').textContent = gameState.population;
            document.getElementById('food').textContent = gameState.food;
            document.getElementById('wood').textContent = gameState.wood;
            document.getElementById('stone').textContent = gameState.stone;
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            // Update workers
            gameState.workers.forEach(worker => {
                // Simple AI: workers move around randomly and collect resources
                if (!worker.userData.target) {
                    worker.userData.target = new THREE.Vector3(
                        (Math.random() - 0.5) * 40,
                        0.5,
                        (Math.random() - 0.5) * 40
                    );
                }

                // Move towards target
                const direction = new THREE.Vector3()
                    .subVectors(worker.userData.target, worker.position)
                    .normalize()
                    .multiplyScalar(worker.userData.speed);
                
                worker.position.add(direction);

                // Check if reached target
                if (worker.position.distanceTo(worker.userData.target) < 1) {
                    worker.userData.target = null;
                    worker.userData.taskTimer++;
                    
                    // Collect resources occasionally
                    if (worker.userData.taskTimer > 100) {
                        const rand = Math.random();
                        if (rand < 0.3) gameState.food += 1;
                        else if (rand < 0.6) gameState.wood += 1;
                        else gameState.stone += 1;
                        worker.userData.taskTimer = 0;
                        updateUI();
                    }
                }
            });

            // Auto-produce resources from buildings
            if (Math.random() < 0.01) { // 1% chance per frame
                gameState.buildings.forEach(building => {
                    if (building.userData.type === 'farm') {
                        gameState.food += 2;
                    } else if (building.userData.type === 'mine') {
                        gameState.stone += 1;
                    }
                });
                updateUI();
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start game
        animate();
        updateUI();
    </script>
</body>
</html>